{"pages":[],"posts":[{"title":"堆排序","text":"什么是堆 堆是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆. ——引用自维基百科 在堆排序中，我们可以将堆看作是父节点的值恒大于等于（或小于等于）其子节点值的完全二叉树。 如何排序 只要我们可以维护上文中这样一个堆，那么我们只要每次取堆顶元素，最终得到的序列一定是有序的。 维护堆完全二叉树的几条性质：1.第i个结点的左儿子是第2*i+1个结点(根基结点从0开始)2.第一个非叶结点点的位置为len/2-1(len为总的结点个数) 只需要从第一个非叶节点内开始，到根节点（即堆顶）使每个节点及其子节点满足堆得性质即可维护一个堆。 图解： C语言代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void HeapAdjustDown(int *arr,int start,int end){ int temp = arr[start]; //保存当前节点 int i = 2*start+1; //该节点的左孩子在数组中的位置序号 while(i&lt;=end) { //找出左右孩子中最大的那个 if(i+1&lt;=end &amp;&amp; arr[i+1]&gt;arr[i]) i++; //如果符合堆的定义，则不用调整位置 if(arr[i]&lt;=temp) break; //最大的子节点向上移动，替换掉其父节点 arr[start] = arr[i]; start = i; i = 2*start+1; } arr[start] = temp;}/*排序后的顺序为从小到大因此需要建立最大堆*/void Heap_Sort(int *arr,int len){ int i; //把数组建成为最大堆 //从第一个非叶结点开始往上调整，使每个结点都满足堆的性质 //第一个非叶子节点的位置序号为len/2-1 for(i=len/2-1;i&gt;=0;i--) HeapAdjustDown(arr,i,len-1); //进行堆排序 for(i=len-1;i&gt;0;i--) { //将堆顶元素与堆的最后一个元素交换 int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; //将arr[0...i-1]重新调整为最大堆 HeapAdjustDown(arr,0,i-1); }}int main(){ int num; scanf(\"%d\",&amp;num); int i; int *arr = (int *)malloc(num*sizeof(int)); for(i=0;i&lt;num;i++) scanf(\"%d\",arr+i); Heap_Sort(arr,num); for(i=0;i&lt;num;i++) printf(\"%d \",arr[i]); printf(\"\\n\"); free(arr); arr = 0; return 0;}","link":"/2019/11/20/Heapsort/"},{"title":"Liunx基本命令总结（一）——文件目录类","text":"最近学习了Linux的一些基本命令，写个博客记录一下，以便之后复习。 1.pwd指令功能描述 ： 显示当前工作目录的绝对路径。基本语法： pwd 2.ls指令功能描述 ： 显示当前目录的内容信息。基本语法： ls [选项] [目录或是文件]常用选项： -a： 显示当前目录所有文件和目录，包括隐藏文件； -l：以列表的形式显示信息； 3.cd指令功能描述 ： 切换工作目录(change directory)；基本语法： cd [参数]常用参数： 一个路径（相对路径和绝对路径都行）；其他参数或用法 cd ..：切换到当前目录的上一级目录； cd ~：回到当前用户的家目录； 4.mkdir指令功能描述 ： 用于创建目录（make directory）；基本语法： mkdir [选项] 要创建的目录常用选项： -p：创建多及目录； 5.rmdir指令功能描述 ： 删除空目录；基本语法： rmdir [选项] 要删除的目录使用细节： rm直接使用删除的是空目录，非空目录无法删除； ps：可以 rm -rf 要删除的目录 删除非空目录； 6.touch指令功能描述 ： 创建空文件；基本语法： touch 文件名称 7.cp指令功能描述 ： 拷贝文件到指定目录；基本语法： cp [选项] 源文件 目标文件常用参数： -r：递归复制整个文件夹；使用细节： 目标目录中有同名文件时默认覆盖的使用方法： \\cp [选项] 源文件 目标文件 ８.rm指令功能描述 ： 删除文件或目录；基本语法： rm [选项] 要删除的文件或目录常用选项： -r：递归删除整个文件夹； -f：强制删除不提示； 9.mv指令功能描述 ： 移动文件与目录或重命名；基本语法： mv oldFileName newFileN mv 要移动的文件 目标位置的路径 10.cat指令功能描述 ： 以只读的方式查看文件内容；基本语法： cat [选项] 要查看的文件；常用选项： -n：显示行号； 11.more指令功能描述 ： more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容；基本语法： more 要查看的文件快捷键： 12.less指令功能描述 ： less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。基本语法： less 要查看的文件快捷键： 13.&gt;指令和&gt;&gt;指令功能描述 ： &gt;：输出重定向，将命令输出的内容写入文件，会覆盖文件原有的内容； &gt;&gt;：追加：将命令输出的内容追加到文件末尾，不会覆盖文件原有内容；用法举例： （1）ls &gt; a.txt ：将ls命令输出的内容写入到文件a.txt； （2）cat a.txt &gt;&gt; b.txt：将cat输出的内容(即文件a.txt的内容)追加到b.txt中。 14.echo指令功能描述 ： 输出内容到控制台；基本语法： echo [选项] 要输出的内容用法举例： echo $PATH ：输出环境变量； 15.head指令功能描述 ： 显示文件的开头部分内容，默认显示前十行；基本语法： head 要查看的文件 head -n5 （查看文件的前5行，5可以使任意数） 16.tail指令功能描述 ： 显示文件的尾部的内容，默认显示最后十行；基本语法： head 要查看的文件 head -n5 要查看的文件（查看文件的候5行，5可以使任意数） head -f 要查看的文件 （实时追踪该文档的所有更新） 17.ln指令功能描述 ： 创建软链接，软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径；基本语法： ln -s [原文件或目录] [软链接名]； 18.history指令功能描述 ： 查看已经执行过的历史命令；基本语法： history （查看所有执行过的历史命令） history 10 （查看执行过的最后十条命令，10可以使任意数） !178 （执行 编号为178的历史命令，178可以是任意数）","link":"/2019/11/05/Liunx-command1/"},{"title":"广度优先搜索求连通块","text":"最近做了好多广搜的题，写个博客作为以后复习的模板，通时也是一种求连通块的方法。 思路用广搜遍历图中的每一个点，在同一次搜索中能遍历到的点则在同一个连通块中（深搜是一样的）。 例题洛谷P1141 01迷宫 题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入格式第1行为两个正整数n,mn,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第ii行第jj列的一个格子，询问从这一格开始能移动到多少格。 输出格式m行，对于每个询问输出相应答案。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;char _map[1001][1001];int flag[1001][1001]; //用来标记当前点在哪个连通块中int ans[1000001]; //用来存第i个连通块中点的数量int _queue[1000001][2]; //广搜用的队列，存储点的坐标（在主函数中定义会爆栈）int main(){ int n, m, d; cin &gt;&gt; n &gt;&gt; m; int next[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; for(int i = 1; i &lt;= n; i ++) //读入地图 for(int j = 1; j &lt;= n; j ++) cin &gt;&gt; _map[i][j]; d = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) { //深搜 if(!flag[i][j]) //如果当前点没有被遍历过，则用深搜遍历 { d ++; //连通块数量加一 flag[i][j] = d; int nx, ny, cx, cy, sum = 1; //sum表示当前连通块中的结点数量 int head = 1; int tail = 1; _queue[1][0] = i; _queue[1][1] = j; tail ++; while(head &lt; tail) { cx = _queue[head][0]; cy = _queue[head][1]; for(int i = 0; i &lt; 4; i++) { nx = _queue[head][0] + next[i][0]; ny = _queue[head][1] + next[i][1]; if(nx &lt;= n &amp;&amp; ny &lt;= n &amp;&amp; nx &gt; 0 &amp;&amp; ny &gt; 0 &amp;&amp; _map[nx][ny] != _map[cx][cy] &amp;&amp; !flag[nx][ny]) { _queue[tail][0] = nx; _queue[tail][1] = ny; tail ++; flag[nx][ny] = d; sum ++; //将连通块中的数量加一 } } head ++; //此处一定要记着将队首出队(经常忘记，汗） } ans[d] = sum; } } for(int i = 1; i &lt;= m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; ans[flag[x][y]] &lt;&lt; endl; }}","link":"/2019/11/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"title":"最长上升子序列的长度(nlogn)","text":"lower_bound与upper_bound这是C++STL中的两个函数lower_bound找出序列中第一个大于等于x的函数(x是一个参数)。upper_bound找出序列中第一个大于x的函数。 这两个函数使用的条件是序列必须是有序的。比如，对于数组a, 在区间[1, n)找第一个大于等于x的数 1lower_bound(a+1， a+1+n, x); 函数的返回值不是数组下表，而是指向目标数的指针，可以通过减数组首地址计算下标。也可以使用*号运算符来取值。 和sort函数一样，可以自定义比较器（默认为&lt;）如果要在降序序列中找第一个小于等于x的数，将比较器改成大于即可 1lower_bound(a+1， a+1+n, x， greater&lt;int&gt;()); 使用这两个函数就避免了我们还需要自己写查找。 例题洛谷P1020 导弹拦截 一个定理：将一个数列换分成n个不降子序列时，n的最小值等于这个序列最长上升自序列的长度。（定理详细内容可以参考这里） 实现代码： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010;int a[N],d1[N],d2[N],n;int main() { while(cin&gt;&gt;a[++n]);n--; //由于OJ用的是文件输入，所以可以使用这样控制输入，本 //本地可以用ctrl + z表示EOF int len1=1,len2=1; //初始长度为1 d1[1]=a[1]; //用于求不上升序列长度 d2[1]=a[1]; //用于求上升序列长度 for(int i=2; i&lt;=n; i++) { //从a[2]开始枚举每个数(a[1]已经加进去了) if(d1[len1]&gt;=a[i])d1[++len1]=a[i]; //如果满足要求(不上升)就加入d1 else { //否则用a[i]替换d1中的一个数 int p1=upper_bound(d1+1,d1+1+len1,a[i],greater&lt;int&gt;())-d1; d1[p1]=a[i]; } if(d2[len2]&lt;a[i])d2[++len2]=a[i]; //同上 else { int p2=lower_bound(d2+1,d2+1+len2,a[i])-d2; d2[p2]=a[i]; } } cout&lt;&lt;len1&lt;&lt;endl&lt;&lt;len2; return 0; }","link":"/2019/11/17/LIS/"},{"title":"并查集","text":"什么是并查集并查集，顾名思义，就是有合并和查询集合的功能。这些功能是如何实现的呢？我们可以将并查集看成一个树形结构，如果两个节点拥有共同的祖先表示他们在同一个集合中。这样，合并也就很好做了，合并两个集合时。只需要让其中一个的祖先成为另一个集合中某个节点的儿子，就完成了两个集合的合并。 存储因为并查集中为们只关心节点的父亲是谁，所以一般用数组来存储并查集。 12345678910## **查询**```C++int find(int x){ if(f[x] = x) return x; return find(f[x]);} 合并1f[find(a)] = b; 路径压缩为了提高查找效率，查找时将点x到根节点路径上的所有点的父节点变成这个集合的更节点，这样就可以减少下次查找的时间,只需要将查询改一下就行。 123456int find(int x){ if(f[x] = x) return x; return f[x] = find(f[x]);} 根据这个思路，合并也可以改为每次讲一个集合的根节点变成另一个集合根节点的一个儿子。即： 1f[find(a)] = find(b); 例题P1196 [NOI2002]银河英雄传说 解题思路本题不仅需要判断是否在一个集合中，还要输出两个点之间的距离，为此我们可以将将每个点到根节点的距离保存下来，每次合并和路径压缩时更新到根节点的距离。最终，我们只需要计算两个点到根节点的距离之差即可求出两个点的距离。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int num[30001], f[30001], s[30001];int _find(int x){ if(f[x] == x) return x; int k = f[x]; f[x] = _find(f[x]); ///路径压缩 s[x] += s[k]; ///更新到根节点的距离， x到根节点的距离就等于x到f[x]的距离加f[x]到根节点的距离。 num[x] = num[f[x]]; ///更新集合大小 return f[x];}void init(){ for(int i = 1; i &lt;= 30000; i++) f[i] = i, num[i] = 1,s[i] = 0;}int main(){ int t; cin &gt;&gt; t; init(); char c; int a, b, da, db; while(t--) { cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == 'M') { da = _find(a); db = _find(b); f[da] = db; s[da] += num[db]; ///到根节点的距离 num[db] += num[da]; ///集合大小 num[da] = num[db]; } else { if(_find(a) == _find(b)) cout &lt;&lt; abs(s[a] - s[b]) - 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; } }}","link":"/2019/11/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"标准C++中的string类的用法总结","text":"标准C++中提供的string类得功能也是非常强大的，一般都能满足我们开发项目时使用。现将具体用法的一部分罗列如下，只起一个抛砖引玉的作用吧，好了，废话少说，直接进入正题吧！ 要想使用标准C++中string类，必须要包含 123#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件using std::string;using std::wstring; 或 1using namespace std; 下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。string和wstring的用法是一样的，以下只用string作介绍： string类的构造函数：12string(const char *s); //用c字符串s初始化string(int n,char c); //用n个字符c初始化 此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ； string类的字符操作：1234const char &amp;operator[](int n)const;const char &amp;at(int n)const;char &amp;operator[](int n);char &amp;at(int n); operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。 123const char *data()const;//返回一个非null终止的c字符数组const char *c_str()const;//返回一个以null终止的c字符串int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目 string的特性描述:123456int capacity()const; //返回当前容量（即string中不必增加内存即可存放的元素个数）int max_size()const; //返回string对象中可存放的最大字符串的长度int size()const; //返回当前字符串的大小int length()const; //返回当前字符串的长度bool empty()const; //当前字符串是否为空void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分 string类的输入输出操作:string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\\n’分开。 string的赋值：1234567string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串string &amp;assign(const char *s);//用c类型字符串s赋值string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串 string的连接：1234567string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾string &amp;append(const char *s); //把c类型字符串s连接到当前字符串结尾string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾string &amp;append(const string &amp;s); //同operator+=()string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾string &amp;append(int n,char c); //在当前字符串结尾添加n个字符cstring &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾 string的比较：1bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等 运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较； 12345678int compare(const string &amp;s) const;//比较当前字符串和s的大小int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中 //pos2开始的n2个字符组成的字符串的大小int compare(const char *s) const;int compare(int pos, int n,const char *s) const;int compare(int pos, int n,const char *s, int pos2) const; compare函数在&gt;时返回1，&lt;时返回-1，==时返回0 string的子串：1string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串 string的交换：1void swap(string &amp;s2); //交换当前字符串与s2的值 string类的查找函数：1234567891011121314151617181920212223242526272829int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置//查找成功时返回所在位置，失败返回string::npos的值int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置int rfind(const char *s, int pos = npos) const;int rfind(const char *s, int pos, int n = npos) const;int rfind(const string &amp;s,int pos = npos) const;//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置int find_first_of(const char *s, int pos = 0) const;int find_first_of(const char *s, int pos, int n) const;int find_first_of(const string &amp;s,int pos = 0) const;//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::nposint find_first_not_of(char c, int pos = 0) const;int find_first_not_of(const char *s, int pos = 0) const;int find_first_not_of(const char *s, int pos,int n) const;int find_first_not_of(const string &amp;s,int pos = 0) const;//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::nposint find_last_of(char c, int pos = npos) const;int find_last_of(const char *s, int pos = npos) const;int find_last_of(const char *s, int pos, int n = npos) const;int find_last_of(const string &amp;s,int pos = npos) const;int find_last_not_of(char c, int pos = npos) const;int find_last_not_of(const char *s, int pos = npos) const;int find_last_not_of(const char *s, int pos, int n) const;int find_last_not_of(const string &amp;s,int pos = npos) const;//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找 string类的替换函数：12345678910string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串sstring &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串sstring &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符cstring &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串sstring &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串sstring &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符cstring &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串 string类的插入函数：123456789string &amp;insert(int p0, const char *s);string &amp;insert(int p0, const char *s, int n);string &amp;insert(int p0,const string &amp;s);string &amp;insert(int p0,const string &amp;s, int pos, int n);//前4个函数在p0位置插入字符串s中pos开始的前n个字符string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符citerator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符void insert(iterator it, int n, char c);//在it处插入n个字符c string类的删除函数123iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串 string类的迭代器处理：string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有： 12345678const_iterator begin()const;iterator begin(); //返回string的起始位置const_iterator end()const;iterator end(); //返回string的最后一个字符后面的位置const_iterator rbegin()const;iterator rbegin(); //返回string的最后一个字符的位置const_iterator rend()const;iterator rend(); //返回string第一个字符位置的前面 rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现 转载说明本文转载自博客园@xFreedom原文链接：https://www.cnblogs.com/xFreedom/archive/2011/05/16/2048037.html","link":"/2019/11/21/%E6%A0%87%E5%87%86C-%E4%B8%AD%E7%9A%84string%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"归并排序","text":"基本思想归并排序是利用分治思想的一种排序算法，该算法将一列数平均分为两份，然后将各自排好序和，再按照大小顺序合并成有序的列数，对于分开后小规模的的数列采用同样的思想，知道分成单个的数，这个时候每个数独自都是有序的，然后一层层合并，最终即可的得到有序的一列数； 图解 图片来自网络， 侵删 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include \"cstdio\"#include \"iostream\"using namespace std;//合并两个排好序的数组void mergearray(int a[], int first, int mid, int last, int temp[]){ int i = first, j = mid + 1, k = 0; //用temp数组做中间变量进行数组的合并 while (i &lt;= mid &amp;&amp; j &lt;= last) { if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i &lt;= mid) temp[k++] = a[i++]; while (j &lt;= last) temp[k++] = a[j++]; for(i = 0; i &lt; k; i++) a[first + i] = temp[i];}//归并排序void mergesort(int a[], int first, int last, int temp[]){ int mid = (first + last) / 2; //二分法递归，直到只有一个数不能再分，即 first = last if(first &lt; last) { mergesort(a, first, mid, temp); //先对左半个数组排序 mergesort(a, mid + 1, last, temp); //在对右半个数组排序 mergearray(a, first, mid, last, temp); //将两个排好序的数组合并 }}int main(){ int a[100], temp[100], n; cin &gt;&gt; n; for(int i=1; i &lt;= n; i++) cin &gt;&gt; a[i]; mergesort(a, 1, n, temp); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";}","link":"/2019/11/07/Mergesorttt/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"广度优先搜索","slug":"广度优先搜索","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"连通块","slug":"连通块","link":"/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"最长子序列","slug":"最长子序列","link":"/tags/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"LiS","slug":"LiS","link":"/tags/LiS/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"转载精华","slug":"转载精华","link":"/categories/%E8%BD%AC%E8%BD%BD%E7%B2%BE%E5%8D%8E/"},{"name":"C++","slug":"转载精华/C","link":"/categories/%E8%BD%AC%E8%BD%BD%E7%B2%BE%E5%8D%8E/C/"}]}