{"pages":[],"posts":[{"title":"最长上升子序列的长度(nlogn)","text":"lower_bound与upper_bound这是C++STL中的两个函数lower_bound找出序列中第一个大于等于x的函数(x是一个参数)。upper_bound找出序列中第一个大于x的函数。 这两个函数使用的条件是序列必须是有序的。比如，对于数组a, 在区间[1, n)找第一个大于等于x的数 1lower_bound(a+1， a+1+n, x); 函数的返回值不是数组下表，而是指向目标数的指针，可以通过减数组首地址计算下标。也可以使用*号运算符来取值。 和sort函数一样，可以自定义比较器（默认为&lt;）如果要在降序序列中找第一个小于等于x的数，将比较器改成大于即可 1lower_bound(a+1， a+1+n, x， greater&lt;int&gt;()); 使用这两个函数就避免了我们还需要自己写查找。 例题洛谷P1020 导弹拦截 一个定理：将一个数列换分成n个不降子序列时，n的最小值等于这个序列最长上升自序列的长度。（定理详细内容可以参考这里） 实现代码： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010;int a[N],d1[N],d2[N],n;int main() { while(cin&gt;&gt;a[++n]);n--; //由于OJ用的是文件输入，所以可以使用这样控制输入，本 //本地可以用ctrl + z表示EOF int len1=1,len2=1; //初始长度为1 d1[1]=a[1]; //用于求不上升序列长度 d2[1]=a[1]; //用于求上升序列长度 for(int i=2; i&lt;=n; i++) { //从a[2]开始枚举每个数(a[1]已经加进去了) if(d1[len1]&gt;=a[i])d1[++len1]=a[i]; //如果满足要求(不上升)就加入d1 else { //否则用a[i]替换d1中的一个数 int p1=upper_bound(d1+1,d1+1+len1,a[i],greater&lt;int&gt;())-d1; d1[p1]=a[i]; } if(d2[len2]&lt;a[i])d2[++len2]=a[i]; //同上 else { int p2=lower_bound(d2+1,d2+1+len2,a[i])-d2; d2[p2]=a[i]; } } cout&lt;&lt;len1&lt;&lt;endl&lt;&lt;len2; return 0; }","link":"/2019/11/17/LIS/"},{"title":"广度优先搜索求连通块","text":"最近做了好多广搜的题，写个博客作为以后复习的模板，通时也是一种求连通块的方法。 思路用广搜遍历图中的每一个点，在同一次搜索中能遍历到的点则在同一个连通块中（深搜是一样的）。 例题洛谷P1141 01迷宫 题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入格式第1行为两个正整数n,mn,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第ii行第jj列的一个格子，询问从这一格开始能移动到多少格。 输出格式m行，对于每个询问输出相应答案。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;char _map[1001][1001];int flag[1001][1001]; //用来标记当前点在哪个连通块中int ans[1000001]; //用来存第i个连通块中点的数量int _queue[1000001][2]; //广搜用的队列，存储点的坐标（在主函数中定义会爆栈）int main(){ int n, m, d; cin &gt;&gt; n &gt;&gt; m; int next[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; for(int i = 1; i &lt;= n; i ++) //读入地图 for(int j = 1; j &lt;= n; j ++) cin &gt;&gt; _map[i][j]; d = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) { //深搜 if(!flag[i][j]) //如果当前点没有被遍历过，则用深搜遍历 { d ++; //连通块数量加一 flag[i][j] = d; int nx, ny, cx, cy, sum = 1; //sum表示当前连通块中的结点数量 int head = 1; int tail = 1; _queue[1][0] = i; _queue[1][1] = j; tail ++; while(head &lt; tail) { cx = _queue[head][0]; cy = _queue[head][1]; for(int i = 0; i &lt; 4; i++) { nx = _queue[head][0] + next[i][0]; ny = _queue[head][1] + next[i][1]; if(nx &lt;= n &amp;&amp; ny &lt;= n &amp;&amp; nx &gt; 0 &amp;&amp; ny &gt; 0 &amp;&amp; _map[nx][ny] != _map[cx][cy] &amp;&amp; !flag[nx][ny]) { _queue[tail][0] = nx; _queue[tail][1] = ny; tail ++; flag[nx][ny] = d; sum ++; //将连通块中的数量加一 } } head ++; //此处一定要记着将队首出队(经常忘记，汗） } ans[d] = sum; } } for(int i = 1; i &lt;= m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; ans[flag[x][y]] &lt;&lt; endl; }}","link":"/2019/11/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"title":"Liunx基本命令总结（一）——文件目录类","text":"最近学习了Linux的一些基本命令，写个博客记录一下，以便之后复习。 1.pwd指令功能描述 ： 显示当前工作目录的绝对路径。基本语法： pwd 2.ls指令功能描述 ： 显示当前目录的内容信息。基本语法： ls [选项] [目录或是文件]常用选项： -a： 显示当前目录所有文件和目录，包括隐藏文件； -l：以列表的形式显示信息； 3.cd指令功能描述 ： 切换工作目录(change directory)；基本语法： cd [参数]常用参数： 一个路径（相对路径和绝对路径都行）；其他参数或用法 cd ..：切换到当前目录的上一级目录； cd ~：回到当前用户的家目录； 4.mkdir指令功能描述 ： 用于创建目录（make directory）；基本语法： mkdir [选项] 要创建的目录常用选项： -p：创建多及目录； 5.rmdir指令功能描述 ： 删除空目录；基本语法： rmdir [选项] 要删除的目录使用细节： rm直接使用删除的是空目录，非空目录无法删除； ps：可以 rm -rf 要删除的目录 删除非空目录； 6.touch指令功能描述 ： 创建空文件；基本语法： touch 文件名称 7.cp指令功能描述 ： 拷贝文件到指定目录；基本语法： cp [选项] 源文件 目标文件常用参数： -r：递归复制整个文件夹；使用细节： 目标目录中有同名文件时默认覆盖的使用方法： \\cp [选项] 源文件 目标文件 ８.rm指令功能描述 ： 删除文件或目录；基本语法： rm [选项] 要删除的文件或目录常用选项： -r：递归删除整个文件夹； -f：强制删除不提示； 9.mv指令功能描述 ： 移动文件与目录或重命名；基本语法： mv oldFileName newFileN mv 要移动的文件 目标位置的路径 10.cat指令功能描述 ： 以只读的方式查看文件内容；基本语法： cat [选项] 要查看的文件；常用选项： -n：显示行号； 11.more指令功能描述 ： more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容；基本语法： more 要查看的文件快捷键： 12.less指令功能描述 ： less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。基本语法： less 要查看的文件快捷键： 13.&gt;指令和&gt;&gt;指令功能描述 ： &gt;：输出重定向，将命令输出的内容写入文件，会覆盖文件原有的内容； &gt;&gt;：追加：将命令输出的内容追加到文件末尾，不会覆盖文件原有内容；用法举例： （1）ls &gt; a.txt ：将ls命令输出的内容写入到文件a.txt； （2）cat a.txt &gt;&gt; b.txt：将cat输出的内容(即文件a.txt的内容)追加到b.txt中。 14.echo指令功能描述 ： 输出内容到控制台；基本语法： echo [选项] 要输出的内容用法举例： echo $PATH ：输出环境变量； 15.head指令功能描述 ： 显示文件的开头部分内容，默认显示前十行；基本语法： head 要查看的文件 head -n5 （查看文件的前5行，5可以使任意数） 16.tail指令功能描述 ： 显示文件的尾部的内容，默认显示最后十行；基本语法： head 要查看的文件 head -n5 要查看的文件（查看文件的候5行，5可以使任意数） head -f 要查看的文件 （实时追踪该文档的所有更新） 17.ln指令功能描述 ： 创建软链接，软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径；基本语法： ln -s [原文件或目录] [软链接名]； 18.history指令功能描述 ： 查看已经执行过的历史命令；基本语法： history （查看所有执行过的历史命令） history 10 （查看执行过的最后十条命令，10可以使任意数） !178 （执行 编号为178的历史命令，178可以是任意数）","link":"/2019/11/05/Liunx-command1/"},{"title":"归并排序","text":"基本思想归并排序是利用分治思想的一种排序算法，该算法将一列数平均分为两份，然后将各自排好序和，再按照大小顺序合并成有序的列数，对于分开后小规模的的数列采用同样的思想，知道分成单个的数，这个时候每个数独自都是有序的，然后一层层合并，最终即可的得到有序的一列数； 图解 图片来自网络， 侵删 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include \"cstdio\"#include \"iostream\"using namespace std;//合并两个排好序的数组void mergearray(int a[], int first, int mid, int last, int temp[]){ int i = first, j = mid + 1, k = 0; //用temp数组做中间变量进行数组的合并 while (i &lt;= mid &amp;&amp; j &lt;= last) { if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i &lt;= mid) temp[k++] = a[i++]; while (j &lt;= last) temp[k++] = a[j++]; for(i = 0; i &lt; k; i++) a[first + i] = temp[i];}//归并排序void mergesort(int a[], int first, int last, int temp[]){ int mid = (first + last) / 2; //二分法递归，直到只有一个数不能再分，即 first = last if(first &lt; last) { mergesort(a, first, mid, temp); //先对左半个数组排序 mergesort(a, mid + 1, last, temp); //在对右半个数组排序 mergearray(a, first, mid, last, temp); //将两个排好序的数组合并 }}int main(){ int a[100], temp[100], n; cin &gt;&gt; n; for(int i=1; i &lt;= n; i++) cin &gt;&gt; a[i]; mergesort(a, 1, n, temp); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";}","link":"/2019/11/07/Mergesorttt/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"最长子序列","slug":"最长子序列","link":"/tags/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"LiS","slug":"LiS","link":"/tags/LiS/"},{"name":"广度优先搜索","slug":"广度优先搜索","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"连通块","slug":"连通块","link":"/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}