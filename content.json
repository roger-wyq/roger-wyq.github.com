{"pages":[],"posts":[{"title":"堆排序","text":"什么是堆 堆是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆. ——引用自维基百科 在堆排序中，我们可以将堆看作是父节点的值恒大于等于（或小于等于）其子节点值的完全二叉树。 如何排序 只要我们可以维护上文中这样一个堆，那么我们只要每次取堆顶元素，最终得到的序列一定是有序的。 维护堆完全二叉树的几条性质：1.第i个结点的左儿子是第2*i+1个结点(根基结点从0开始)2.第一个非叶结点点的位置为len/2-1(len为总的结点个数) 只需要从第一个非叶节点内开始，到根节点（即堆顶）使每个节点及其子节点满足堆得性质即可维护一个堆。 图解： C语言代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void HeapAdjustDown(int *arr,int start,int end){ int temp = arr[start]; //保存当前节点 int i = 2*start+1; //该节点的左孩子在数组中的位置序号 while(i&lt;=end) { //找出左右孩子中最大的那个 if(i+1&lt;=end &amp;&amp; arr[i+1]&gt;arr[i]) i++; //如果符合堆的定义，则不用调整位置 if(arr[i]&lt;=temp) break; //最大的子节点向上移动，替换掉其父节点 arr[start] = arr[i]; start = i; i = 2*start+1; } arr[start] = temp;}/*排序后的顺序为从小到大因此需要建立最大堆*/void Heap_Sort(int *arr,int len){ int i; //把数组建成为最大堆 //从第一个非叶结点开始往上调整，使每个结点都满足堆的性质 //第一个非叶子节点的位置序号为len/2-1 for(i=len/2-1;i&gt;=0;i--) HeapAdjustDown(arr,i,len-1); //进行堆排序 for(i=len-1;i&gt;0;i--) { //将堆顶元素与堆的最后一个元素交换 int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; //将arr[0...i-1]重新调整为最大堆 HeapAdjustDown(arr,0,i-1); }}int main(){ int num; scanf(\"%d\",&amp;num); int i; int *arr = (int *)malloc(num*sizeof(int)); for(i=0;i&lt;num;i++) scanf(\"%d\",arr+i); Heap_Sort(arr,num); for(i=0;i&lt;num;i++) printf(\"%d \",arr[i]); printf(\"\\n\"); free(arr); arr = 0; return 0;}","link":"/2019/11/20/Heapsort/"},{"title":"Liunx基本命令总结（一）——文件目录类","text":"最近学习了Linux的一些基本命令，写个博客记录一下，以便之后复习。 1.pwd指令功能描述 ： 显示当前工作目录的绝对路径。基本语法： pwd 2.ls指令功能描述 ： 显示当前目录的内容信息。基本语法： ls [选项] [目录或是文件]常用选项： -a： 显示当前目录所有文件和目录，包括隐藏文件； -l：以列表的形式显示信息； 3.cd指令功能描述 ： 切换工作目录(change directory)；基本语法： cd [参数]常用参数： 一个路径（相对路径和绝对路径都行）；其他参数或用法 cd ..：切换到当前目录的上一级目录； cd ~：回到当前用户的家目录； 4.mkdir指令功能描述 ： 用于创建目录（make directory）；基本语法： mkdir [选项] 要创建的目录常用选项： -p：创建多及目录； 5.rmdir指令功能描述 ： 删除空目录；基本语法： rmdir [选项] 要删除的目录使用细节： rm直接使用删除的是空目录，非空目录无法删除； ps：可以 rm -rf 要删除的目录 删除非空目录； 6.touch指令功能描述 ： 创建空文件；基本语法： touch 文件名称 7.cp指令功能描述 ： 拷贝文件到指定目录；基本语法： cp [选项] 源文件 目标文件常用参数： -r：递归复制整个文件夹；使用细节： 目标目录中有同名文件时默认覆盖的使用方法： \\cp [选项] 源文件 目标文件 ８.rm指令功能描述 ： 删除文件或目录；基本语法： rm [选项] 要删除的文件或目录常用选项： -r：递归删除整个文件夹； -f：强制删除不提示； 9.mv指令功能描述 ： 移动文件与目录或重命名；基本语法： mv oldFileName newFileN mv 要移动的文件 目标位置的路径 10.cat指令功能描述 ： 以只读的方式查看文件内容；基本语法： cat [选项] 要查看的文件；常用选项： -n：显示行号； 11.more指令功能描述 ： more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容；基本语法： more 要查看的文件快捷键： 12.less指令功能描述 ： less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。基本语法： less 要查看的文件快捷键： 13.&gt;指令和&gt;&gt;指令功能描述 ： &gt;：输出重定向，将命令输出的内容写入文件，会覆盖文件原有的内容； &gt;&gt;：追加：将命令输出的内容追加到文件末尾，不会覆盖文件原有内容；用法举例： （1）ls &gt; a.txt ：将ls命令输出的内容写入到文件a.txt； （2）cat a.txt &gt;&gt; b.txt：将cat输出的内容(即文件a.txt的内容)追加到b.txt中。 14.echo指令功能描述 ： 输出内容到控制台；基本语法： echo [选项] 要输出的内容用法举例： echo $PATH ：输出环境变量； 15.head指令功能描述 ： 显示文件的开头部分内容，默认显示前十行；基本语法： head 要查看的文件 head -n5 （查看文件的前5行，5可以使任意数） 16.tail指令功能描述 ： 显示文件的尾部的内容，默认显示最后十行；基本语法： head 要查看的文件 head -n5 要查看的文件（查看文件的候5行，5可以使任意数） head -f 要查看的文件 （实时追踪该文档的所有更新） 17.ln指令功能描述 ： 创建软链接，软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径；基本语法： ln -s [原文件或目录] [软链接名]； 18.history指令功能描述 ： 查看已经执行过的历史命令；基本语法： history （查看所有执行过的历史命令） history 10 （查看执行过的最后十条命令，10可以使任意数） !178 （执行 编号为178的历史命令，178可以是任意数）","link":"/2019/11/05/Liunx-command1/"},{"title":"堆","text":"这是一篇堆的模板。 题目描述如题，初始小根堆为空，我们需要支持以下3种操作： 操作1： 1 x 表示将x插入到堆中 操作2： 2 输出该小根堆内的最小数 操作3： 3 删除该小根堆内的最小数 输入格式第一行包含一个整数N，表示操作的个数 接下来N行，每行包含1个或2个正整数，表示三种操作，格式如下： 操作1： 1 x 操作2： 2 操作3： 3 输出格式包含若干行正整数，每行依次对应一个操作2的结果。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;int heap[1000001], len, n;//从最后一个结点向上调整堆void adjustup() { int start = len; int i = start/2; while(i) { if(heap[i]&gt;heap[start]) { swap(heap[i], heap[start]); start = i; i = start/2; } else break; }}//从根节点向下调整堆void adjustdown(){ int start = 1; int i = 2*start; while(i &lt;= len) { if(i+1 &lt;= len &amp;&amp; heap[i] &gt; heap[i+1]) //找出子节点中较小的一个，此处一定要判断是否越界 i++; if(heap[i] &lt; heap[start]) { swap(heap[i], heap[start]); start = i; i = start*2; } else break; }}//插入节点void h_insert(int x){ heap[++len] = x; adjustup();}//删除节点void del(){ swap(heap[1], heap[len]); len--; adjustdown();}//输出堆顶元素void print(){ cout &lt;&lt; heap[1] &lt;&lt; endl;}int main(){ int k, x; len = 0; cin &gt;&gt; n; while(n--) { cin &gt;&gt; k; if(k == 1) { cin &gt;&gt; x; h_insert(x); } else if(k == 2) print(); else del(); } return 0;}","link":"/2019/12/08/%E5%A0%86/"},{"title":"并查集","text":"什么是并查集并查集，顾名思义，就是有合并和查询集合的功能。这些功能是如何实现的呢？我们可以将并查集看成一个树形结构，如果两个节点拥有共同的祖先表示他们在同一个集合中。这样，合并也就很好做了，合并两个集合时。只需要让其中一个的祖先成为另一个集合中某个节点的儿子，就完成了两个集合的合并。 存储因为并查集中为们只关心节点的父亲是谁，所以一般用数组来存储并查集。f[i]=j表示i的父节点是j。 查询123456int find(int x){ if(f[x] = x) return x; return find(f[x]);} 合并1f[find(a)] = b; 路径压缩为了提高查找效率，查找时将点x到根节点路径上的所有点的父节点变成这个集合的更节点，这样就可以减少下次查找的时间,只需要将查询改一下就行。 123456int find(int x){ if(f[x] = x) return x; return f[x] = find(f[x]);} 根据这个思路，合并也可以改为每次讲一个集合的根节点变成另一个集合根节点的一个儿子。即： 1f[find(a)] = find(b); 例题P1196 [NOI2002]银河英雄传说 解题思路本题不仅需要判断是否在一个集合中，还要输出两个点之间的距离，为此我们可以将将每个点到根节点的距离保存下来，每次合并和路径压缩时更新到根节点的距离。最终，我们只需要计算两个点到根节点的距离之差即可求出两个点的距离。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int num[30001], f[30001], s[30001];int _find(int x){ if(f[x] == x) return x; int k = f[x]; f[x] = _find(f[x]); ///路径压缩 s[x] += s[k]; ///更新到根节点的距离， x到根节点的距离就等于x到f[x]的距离加f[x]到根节点的距离。 num[x] = num[f[x]]; ///更新集合大小 return f[x];}void init(){ for(int i = 1; i &lt;= 30000; i++) f[i] = i, num[i] = 1,s[i] = 0;}int main(){ int t; cin &gt;&gt; t; init(); char c; int a, b, da, db; while(t--) { cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == 'M') { da = _find(a); db = _find(b); f[da] = db; s[da] += num[db]; ///到根节点的距离 num[db] += num[da]; ///集合大小 num[da] = num[db]; } else { if(_find(a) == _find(b)) cout &lt;&lt; abs(s[a] - s[b]) - 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; } }}","link":"/2019/11/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"广度优先搜索求连通块","text":"最近做了好多广搜的题，写个博客作为以后复习的模板，通时也是一种求连通块的方法。 思路用广搜遍历图中的每一个点，在同一次搜索中能遍历到的点则在同一个连通块中（深搜是一样的）。 例题洛谷P1141 01迷宫 题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入格式第1行为两个正整数n,mn,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第ii行第jj列的一个格子，询问从这一格开始能移动到多少格。 输出格式m行，对于每个询问输出相应答案。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;char _map[1001][1001];int flag[1001][1001]; //用来标记当前点在哪个连通块中int ans[1000001]; //用来存第i个连通块中点的数量int _queue[1000001][2]; //广搜用的队列，存储点的坐标（在主函数中定义会爆栈）int main(){ int n, m, d; cin &gt;&gt; n &gt;&gt; m; int next[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; for(int i = 1; i &lt;= n; i ++) //读入地图 for(int j = 1; j &lt;= n; j ++) cin &gt;&gt; _map[i][j]; d = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) { //深搜 if(!flag[i][j]) //如果当前点没有被遍历过，则用深搜遍历 { d ++; //连通块数量加一 flag[i][j] = d; int nx, ny, cx, cy, sum = 1; //sum表示当前连通块中的结点数量 int head = 1; int tail = 1; _queue[1][0] = i; _queue[1][1] = j; tail ++; while(head &lt; tail) { cx = _queue[head][0]; cy = _queue[head][1]; for(int i = 0; i &lt; 4; i++) { nx = _queue[head][0] + next[i][0]; ny = _queue[head][1] + next[i][1]; if(nx &lt;= n &amp;&amp; ny &lt;= n &amp;&amp; nx &gt; 0 &amp;&amp; ny &gt; 0 &amp;&amp; _map[nx][ny] != _map[cx][cy] &amp;&amp; !flag[nx][ny]) { _queue[tail][0] = nx; _queue[tail][1] = ny; tail ++; flag[nx][ny] = d; sum ++; //将连通块中的数量加一 } } head ++; //此处一定要记着将队首出队(经常忘记，汗） } ans[d] = sum; } } for(int i = 1; i &lt;= m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; ans[flag[x][y]] &lt;&lt; endl; }}","link":"/2019/11/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"title":"标准C++中的string类的用法总结","text":"标准C++中提供的string类得功能也是非常强大的，一般都能满足我们开发项目时使用。现将具体用法的一部分罗列如下，只起一个抛砖引玉的作用吧，好了，废话少说，直接进入正题吧！ 要想使用标准C++中string类，必须要包含 123#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件using std::string;using std::wstring; 或 1using namespace std; 下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。string和wstring的用法是一样的，以下只用string作介绍： string类的构造函数：12string(const char *s); //用c字符串s初始化string(int n,char c); //用n个字符c初始化 此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ； string类的字符操作：1234const char &amp;operator[](int n)const;const char &amp;at(int n)const;char &amp;operator[](int n);char &amp;at(int n); operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。 123const char *data()const;//返回一个非null终止的c字符数组const char *c_str()const;//返回一个以null终止的c字符串int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目 string的特性描述:123456int capacity()const; //返回当前容量（即string中不必增加内存即可存放的元素个数）int max_size()const; //返回string对象中可存放的最大字符串的长度int size()const; //返回当前字符串的大小int length()const; //返回当前字符串的长度bool empty()const; //当前字符串是否为空void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分 string类的输入输出操作:string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\\n’分开。 string的赋值：1234567string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串string &amp;assign(const char *s);//用c类型字符串s赋值string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串 string的连接：1234567string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾string &amp;append(const char *s); //把c类型字符串s连接到当前字符串结尾string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾string &amp;append(const string &amp;s); //同operator+=()string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾string &amp;append(int n,char c); //在当前字符串结尾添加n个字符cstring &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾 string的比较：1bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等 运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较； 12345678int compare(const string &amp;s) const;//比较当前字符串和s的大小int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中 //pos2开始的n2个字符组成的字符串的大小int compare(const char *s) const;int compare(int pos, int n,const char *s) const;int compare(int pos, int n,const char *s, int pos2) const; compare函数在&gt;时返回1，&lt;时返回-1，==时返回0 string的子串：1string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串 string的交换：1void swap(string &amp;s2); //交换当前字符串与s2的值 string类的查找函数：1234567891011121314151617181920212223242526272829int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置//查找成功时返回所在位置，失败返回string::npos的值int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置int rfind(const char *s, int pos = npos) const;int rfind(const char *s, int pos, int n = npos) const;int rfind(const string &amp;s,int pos = npos) const;//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置int find_first_of(const char *s, int pos = 0) const;int find_first_of(const char *s, int pos, int n) const;int find_first_of(const string &amp;s,int pos = 0) const;//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::nposint find_first_not_of(char c, int pos = 0) const;int find_first_not_of(const char *s, int pos = 0) const;int find_first_not_of(const char *s, int pos,int n) const;int find_first_not_of(const string &amp;s,int pos = 0) const;//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::nposint find_last_of(char c, int pos = npos) const;int find_last_of(const char *s, int pos = npos) const;int find_last_of(const char *s, int pos, int n = npos) const;int find_last_of(const string &amp;s,int pos = npos) const;int find_last_not_of(char c, int pos = npos) const;int find_last_not_of(const char *s, int pos = npos) const;int find_last_not_of(const char *s, int pos, int n) const;int find_last_not_of(const string &amp;s,int pos = npos) const;//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找 string类的替换函数：12345678910string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串sstring &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串sstring &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符cstring &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串sstring &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串sstring &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符cstring &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串 string类的插入函数：123456789string &amp;insert(int p0, const char *s);string &amp;insert(int p0, const char *s, int n);string &amp;insert(int p0,const string &amp;s);string &amp;insert(int p0,const string &amp;s, int pos, int n);//前4个函数在p0位置插入字符串s中pos开始的前n个字符string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符citerator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符void insert(iterator it, int n, char c);//在it处插入n个字符c string类的删除函数123iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串 string类的迭代器处理：string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有： 12345678const_iterator begin()const;iterator begin(); //返回string的起始位置const_iterator end()const;iterator end(); //返回string的最后一个字符后面的位置const_iterator rbegin()const;iterator rbegin(); //返回string的最后一个字符的位置const_iterator rend()const;iterator rend(); //返回string第一个字符位置的前面 rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现 转载说明本文转载自博客园@xFreedom原文链接：https://www.cnblogs.com/xFreedom/archive/2011/05/16/2048037.html","link":"/2019/11/21/%E6%A0%87%E5%87%86C-%E4%B8%AD%E7%9A%84string%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"最长上升子序列的长度(nlogn)","text":"lower_bound与upper_bound这是C++STL中的两个函数lower_bound找出序列中第一个大于等于x的函数(x是一个参数)。upper_bound找出序列中第一个大于x的函数。 这两个函数使用的条件是序列必须是有序的。比如，对于数组a, 在区间[1, n)找第一个大于等于x的数 1lower_bound(a+1， a+1+n, x); 函数的返回值不是数组下表，而是指向目标数的指针，可以通过减数组首地址计算下标。也可以使用*号运算符来取值。 和sort函数一样，可以自定义比较器（默认为&lt;）如果要在降序序列中找第一个小于等于x的数，将比较器改成大于即可 1lower_bound(a+1， a+1+n, x， greater&lt;int&gt;()); 使用这两个函数就避免了我们还需要自己写查找。 例题洛谷P1020 导弹拦截 一个定理：将一个数列换分成n个不降子序列时，n的最小值等于这个序列最长上升自序列的长度。（定理详细内容可以参考这里） 实现代码： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010;int a[N],d1[N],d2[N],n;int main() { while(cin&gt;&gt;a[++n]);n--; //由于OJ用的是文件输入，所以可以使用这样控制输入，本 //本地可以用ctrl + z表示EOF int len1=1,len2=1; //初始长度为1 d1[1]=a[1]; //用于求不上升序列长度 d2[1]=a[1]; //用于求上升序列长度 for(int i=2; i&lt;=n; i++) { //从a[2]开始枚举每个数(a[1]已经加进去了) if(d1[len1]&gt;=a[i])d1[++len1]=a[i]; //如果满足要求(不上升)就加入d1 else { //否则用a[i]替换d1中的一个数 int p1=upper_bound(d1+1,d1+1+len1,a[i],greater&lt;int&gt;())-d1; d1[p1]=a[i]; } if(d2[len2]&lt;a[i])d2[++len2]=a[i]; //同上 else { int p2=lower_bound(d2+1,d2+1+len2,a[i])-d2; d2[p2]=a[i]; } } cout&lt;&lt;len1&lt;&lt;endl&lt;&lt;len2; return 0; }","link":"/2019/11/17/LIS/"},{"title":"归并排序","text":"基本思想归并排序是利用分治思想的一种排序算法，该算法将一列数平均分为两份，然后将各自排好序和，再按照大小顺序合并成有序的列数，对于分开后小规模的的数列采用同样的思想，知道分成单个的数，这个时候每个数独自都是有序的，然后一层层合并，最终即可的得到有序的一列数； 图解 图片来自网络， 侵删 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include \"cstdio\"#include \"iostream\"using namespace std;//合并两个排好序的数组void mergearray(int a[], int first, int mid, int last, int temp[]){ int i = first, j = mid + 1, k = 0; //用temp数组做中间变量进行数组的合并 while (i &lt;= mid &amp;&amp; j &lt;= last) { if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i &lt;= mid) temp[k++] = a[i++]; while (j &lt;= last) temp[k++] = a[j++]; for(i = 0; i &lt; k; i++) a[first + i] = temp[i];}//归并排序void mergesort(int a[], int first, int last, int temp[]){ int mid = (first + last) / 2; //二分法递归，直到只有一个数不能再分，即 first = last if(first &lt; last) { mergesort(a, first, mid, temp); //先对左半个数组排序 mergesort(a, mid + 1, last, temp); //在对右半个数组排序 mergearray(a, first, mid, last, temp); //将两个排好序的数组合并 }}int main(){ int a[100], temp[100], n; cin &gt;&gt; n; for(int i=1; i &lt;= n; i++) cin &gt;&gt; a[i]; mergesort(a, 1, n, temp); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";}","link":"/2019/11/07/Mergesorttt/"},{"title":"第一章 开始","text":"1.1函数的定义的四部分一个函数定的义包括四部分：返回类型（return type）、函数名（function name）、一个括号包围的参数列表（parameter list，允许为空）以及函数体（function body)。 1.2流一个流就是一个字符序列，是从IO设备读入或写出IO设备的。 标准输入输出对象cin：istream类型的对象，标准输入。 cout：ostream类型的对象，标准输出。 cerr：ostream类型，标准错误，用来输出错误信息。 clog：ostream类型，用来输出程序运行时的一般信息。 表达式最小的计算单元，一个表达式包含一个或多个对象，通常还包含一个或多个运算符。表达式会产生一个或多个运算结果。 运算符 &lt;&lt; 和 &gt;&gt;的返回流运算符 &lt;&lt; 和 &gt;&gt; 均返回其左侧的运算对象。例：std::cout &lt;&lt; &quot;hello&quot;的返回值为std::cout。 命名空间将库定义的名字放在一个单一位置的机制。命名空间可以帮助避免不经意的名字冲突。C++标准库定义的名字在命名空间std中。 1.4语句块所谓语句块，就是用花括号包围的零条或多条语句的序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。 1.5类一种用于定义自己数据结构及其相关操作的机制。类是C++中最基本的特性之一。 文件重定向文件重定向就是讲标准输入和标准输出与命名文件关联起来。 例：addItmes &lt;infile &gt;outfile 其中addItmes 是可执行文件，infile和outfile是要重定向的输入输出文件。","link":"/2020/01/08/C++Prime/%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"title":"2.5 处理类型","text":"2.5.1 类型别名类型别名是一个名字，它是某种类型的同义词。 有两种方法 用于定义类型别名： 关键字typedef 12typedef double wages; // wages是double的同义词；typedef wages base, *p; // base是double的同义词，p是double*的同义词 使用using别名声明 1using SI = Sales_itme; // SI是Sales_itme的同义词 注意： 123typedef char *pstring;const pstring cstr = 0; // cstr是指向char的常量指针const char *cstr = 0; // cstr是指向const char的指针 2.5.2 auto 类型说明符编程时常常需要把表达式的值赋给变量，但有时候我们不能清楚的知道表达式的类型。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器代替我们去分析表达式所属的类型。因此，auto定义的变量必须有初始值。 1auto item = val1 + val2; // item的类型是根据val1和val2相加的结果推出来的 使用auto在一条语句中声明多个变量时，该语句中所有变量的初始基本类型都必须一样。 2.5.3 decltype 类型指示符decltype的用法类似于函数，它的作用是选择并返回操作数的数据类型； 1decltype(f()) sum = x; // sum的类型就是函数f的返回值类型； decltype处理顶层const和引用的方式与auto有些许不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括const和引用在内）。 1234const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x的类型是const int;decltype(cj) y = x; // y的类型是const int&amp;;decltype(cj) z; // 错误，z是一个引用，必须初始化。 引用从来都作为其所指对象的同义词出现，只有在decltype处是一个例外。","link":"/2020/01/22/C++Prime/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.5%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/"},{"title":"2.4 const限定符","text":"const是一种类型修饰符，用于说明永不改变的对象。const对象一旦改变就无法再赋新值，所以必须初始化。 const对象的有效范围默认情况下，const对象仅在文件内有效。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字。 2.4.1 const引用把引用绑定到const对象上，称之为对常量的引用，对常量的引用不能用作修改它所绑定对象的值。引用常量的引用也必须是常量引用，即用const修饰。 123const int a = 128;int &amp;b = a; // 错误const int &amp;c = a; // 正确 C++允许一个常量引用绑定到非常量的对象，字面值，甚至是一个一般表达式。这是引用的特殊情况之一，一般情况下，引用类型必须与其所引用对象的类型一致。 2.4.2 指针和const可以让指针指向常量，指向常量的指针不能用于改变其所指对象的值。而想要存放常量对象的地址，只能使用指向常量的指针，即用const修饰的指针。 1234const double pi = 3.14;double *ptr = &amp;pi; // 错误const double *cptr = &amp;pi // 正确*cptr = 42; // 错误 const指针指针本身也可是是一个常量，即存放在指针中的那个地址不变。因此，const指针(即常量指针)必须初始化。 1234int errNumb = 0;int *const curNumb = &amp;errNumb; // curNumb将一直指向errNumb;const double pi = 3.14;const double *const pip = &amp;pi; // pip是一个指向常量对象的常量指针。 2.4.3 顶层const对于指针，用顶层const表示指针本身是个常量，用底层const表示指针所指对象是一个常量。 2.4.4 constexpr和常量表达式常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。 1234const int max_files = 20; // max_files是常量表达式const int limit = max_files + 1; // limit是常量表达式int staff_size = 27; // staff_szie不是常量表达式const int sz = get_size(); // sz不是常量表达式 constexpr变量对于不能确定初始值是不是常量表达式的情况，C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的初始值是否是一个常量表达式。","link":"/2020/01/21/C++Prime/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.4const%E9%99%90%E5%AE%9A%E7%AC%A6/"},{"title":"2.2 变量","text":"变量提供一个具名的，可供程序操作的存储空间。 2.2.1 变量定义初始化当对象在创建时获得一个特定的值，我们说这个对象被初始化了。在C++中，初始化和赋值是两种完全不同的操作。初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替。 列表初始化C++语言定义了初始化的好几种不同形式： 1234int units_sold = 0;int units_sold = {0};int units_sold{0};int units_sold(0); 2.2.2 变量声明和定义的关系声明使得名字为程序所知，一个文件如果想要使用别处定义的的名字则必须包含对那个名字的声明。 定义 负责创建于名字关联的实体。 如果想声明一个变量而非定义它，就在变量名前面加上关键字extern, 而且不要显式地初始化： 123extern int i; //声明i而非定义iint j; //声明并定义jextern double pi = 3.14; //定义 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 变量能且只能被定义一次，但可以被多次声明 2.2.3 标识符C++的标识符由数字，字母和下划线组成。必须以下划线或者字母开头。 下图中的C++关键字和操作符代替名不能被用作操作符。 用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧跟大写字母开头。定义在函数体外的标识符不能以下划线开头。 C++中的关键字 [![l4VMMq.md.jpg](https://s2.ax1x.com/2020/01/10/l4VMMq.md.jpg)](https://imgchr.com/i/l4VMMq) C++操作符代替名","link":"/2020/01/10/C++Prime/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.2%E5%8F%98%E9%87%8F/"},{"title":"3.2 标准库类型string","text":"3.2.1 定义和初始化string对象 初始化string对象的方法 3.2.2 string对象上的操作 string上的操作 字面值和string对象相加当string对象和字符串字面值或者字符字面值相加时，其结果会转换为string对象。 但是当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保加法运算符的两侧的运算符对象至少有一个是string。 1234string s4 = s1 + \",\"; // 正确string s5 = \"hello\" + \",\"; // 错误string s6 = s1 + \",\" + \"world\"; // 正确string s7 = \"hello\" + \",\" + s2; // 错误 3.2.3 处理string对象中的字符使用cctype头文件操作字符 cctype头文件中的函数 范围for语句C++11新标准提供了一种新的语句：范围for语句。其语法形式是： 12for(declaration : expression) statement 其中，expression是一个对象，表示一个序列，declaration部分负责定义一个变量，该变量被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。 用法举例： 12345// 从键盘输入一个字符串，然后再依次输出字符串中每个字符，用空格隔开string s1;cin &gt;&gt; s1;for(auto c : s1) cout &lt;&lt; c &lt;&lt; ' '; 使用范围for语句改变字符串中的字符如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。 1234string s(\"Hello World!!!\");for(auto &amp;c : s) c = toupper(c);cout &lt;&lt; s &lt;&lt; endl;","link":"/2020/01/23/C++Prime/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.2%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/"},{"title":"2.1 基本内置类型","text":"2.1.1 算数类型算数类型及其大小 算数类型包括整形（包括字符型和布尔型两类）和浮点型。 算数类型的大小在不同的机器上有差别，下图列出了C++标准规定的大小的最小值。 其中，wchar_t是宽字符，char16_t和char32_t是Unicode字符。 带符号类型和无符号类型除去布尔型和和拓展的字符型外，其他整形科划分为带符号的无符号的(signed)和无符号的(unsigned)两种。带符号的可以表示负数，0，正数，而无符号的则只能表示大于等于0的数。 类型int,long,long long都是带符号类型，通过在这些类型名前添加unsigned可以得到其对应的无符号类型。其中unsigned int可以简写为unsigned。 和其他整形不同的是，字符型被分成了char,signed char,unsigned char三种，但是只表现带符号和无符号两种，char会和另外两种的某种相同，具体和哪个相同由编译器决定。 2.1.2 类型转换类型转换规则123456bool b = 42; // b为真int i = b; // i的值为1i = 3.14; // i的值为3double pi = i; // pi的值为3.0unsigned char c = -1; // 假设char占8bit, c的值为255signed char c2 = 256; // 假设char占8bit, c2的值是未定义的 注意： 当我们赋给带符号类型一个超出它的范围的值是，结果是未定义的，此时，程序可能是继续个工作、可能崩溃、也可能产生垃圾数据。 表达式中含有无符号类型时的问题如果表达式中既有带符号类型又有无符号类，当带符号类型取值为负时会出现异常，这是因为带符号是会自动转换成无符号数。 例： 1234unsigned u = 10;int i = -42;std::cout &lt;&lt; i + i &lt;&lt; std::endl; // 输出 -84std::cout &lt;&lt; u + i &lt;&lt; std::endl; // 如果int占32位, 输出4294967264 2.1.3 字面值常量字面值常量即常量，每个常量的形式和值决定了他的数据类型。 整型和浮点型字面值整型字面值可以写作十进制，八进制或十六进制。 例如： 12320 // 十进制024 // 八进制0x14 // 十六进制 都可以表示十进制的数值20.其中以0开头表示八进制，0x或0X开头表示16进制。 整形的具体数据类型由他的值和符号决定。 默认情况下： 十进制的字面值是带符号的，八进制和十六进制即可能是带符号的，也可能是无符号的。十进制的字面值类型是在能容纳的前提下int,long和long long中最小的一个。八进制和十六进制是能容纳其数值的int,unsigned int, long,unsigned long, long long或unsigned long long中最小的一个。 浮点型字面值表现为小数或者以科学计数法表示的指数： 13.14159 3.14159E0 0. 0e0 .001 浮点数的字面值数据类型默认是double 字符和字符串字面值12'a' // 字符字面值\"Hello World!\" // 字符串字面值 如果两个字符串字面值紧邻且仅由空格，缩进和换行分割，则他们实际是一个整体。因此，可以这样写代码： 12std::cout &lt;&lt; \"a really, really long string literal \"\"that spans two lines\" &lt;&lt; std::endl; 转义序列有两类字符程序员不能直接使用： 1.不可打印的字符。如退格或者其他字符，因为他们没有可视的图符。 2.在C++语言中拥有特殊含义的字符（单引号，引号，反斜线，问号）。 这些情况下需要用到转义字符。 C++语言规定的转义序列有: 名称 符号 名称 符号 名称 符号 换行符 \\n 横向制表符 \\t 报警(响铃)符 \\a 纵向制表符 \\v 退格符 \\b 单引号 \\’ 反斜线 \\\\ 问号 \\？ 双引号 \\“ 回车符 \\r 换行符 \\n 指定字面值的类型通过添加下表所列的前缀和后缀，可以改变整形，浮点型和字符型字面值的默认值。 例： 12345L'a' // 宽字符字面值，类型是wchar_tu8\"hi!\" // utf-8字符串字面值42ULL // 无符号整形字面值，类型是unsigned long long1E-3F // 单精度浮点型字面值，类型是flaot3.14159L // long double","link":"/2020/01/10/C++Prime/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.1%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/"},{"title":"2.3 复合类型","text":"复合类型是指基于其他类型定义的类型。 2.3.1 引用引用类型为对象起了另外一个名字。 123int ival = 1024;int &amp;refVal = ival; // refVal指向ival(是ival的另一个名字，不是别名)int &amp;refVal2; // 报错：引用必须初始化。 引用并非对象，相反的，他只是为一个已经存在的对象所起的另外一个名字 引用的定义： 1234int i = 1024, i2 = 2048;int &amp;r = i, r2 = i2; // r是一i的个引用，而r2是一个intint i3 = 2024, &amp;ri = i3; // i3是一个应用，ri是r3的一个引用int &amp;r3 = i3, &amp;r4 = i2; // r3和r4都是引用 引用只能绑定在对象上，而不能与字面值或某个表达式计算的结果绑定在一起，同时引用的类型要与与之绑定的对象相匹配： 123int &amp;refVal4 = 10; // 错误！duoble dval = 3.14;int &amp;refVal5 = dval; // 错误，引用类型的初始值必须为int 2.3.2 指针指针是“指向”另外一种类型的复合类型； 把int变量直接赋值给指针是错误的操作，即使int变量的值恰好等于0也不行。 void* 指针 void* 指针是一种特殊的指针，可用于存放任意地址的对象。但是void*指针没办法访问内存空间中的对象。 2.3.3 理解复合类型的声明一条定义语句可以定义出不同类型的变量： 1int i = 1024, *p = &amp;i, &amp;r = i; 指向指针的指针声明中修饰符的个数并没有限制，且指针是内存中的对象，想其他对象一样也有自己的地址，因此允许把指针的地址在放在另一个指针中。 通过的个数可以区分指针的级别。即，* 是指向指针的指针， ***表示指向指针的指针的指针。 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针（注）。单指针是对象，所以存在对指针的引用。 例如： 123int i = 42;int *p;int *&amp;r = p; tips:面对一条比较复杂的指针或者引用的声明语句时，从有向左有助于弄清他的真实含义。 *注意：此处所说的不能定义指向应用的指针是指`int &amp;p1 = p`这类定义是错误的 ** 即： 1234int val = 42;int &amp;r = val;int *p = &amp;r; // 正确int &amp;*p1 = p; // 错误","link":"/2020/01/10/C++Prime/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"广度优先搜索","slug":"广度优先搜索","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"连通块","slug":"连通块","link":"/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"最长子序列","slug":"最长子序列","link":"/tags/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/"},{"name":"LiS","slug":"LiS","link":"/tags/LiS/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"C++Primer","slug":"C-Primer","link":"/tags/C-Primer/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"转载精华","slug":"转载精华","link":"/categories/%E8%BD%AC%E8%BD%BD%E7%B2%BE%E5%8D%8E/"},{"name":"C++","slug":"转载精华/C","link":"/categories/%E8%BD%AC%E8%BD%BD%E7%B2%BE%E5%8D%8E/C/"},{"name":"C++Primer笔记","slug":"C-Primer笔记","link":"/categories/C-Primer%E7%AC%94%E8%AE%B0/"},{"name":"第一章","slug":"C-Primer笔记/第一章","link":"/categories/C-Primer%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"name":"第二章","slug":"C-Primer笔记/第二章","link":"/categories/C-Primer%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"name":"第三章","slug":"C-Primer笔记/第三章","link":"/categories/C-Primer%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AB%A0/"}]}